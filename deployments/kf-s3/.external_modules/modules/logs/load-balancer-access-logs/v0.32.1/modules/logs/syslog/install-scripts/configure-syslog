#!/bin/bash
#
# Configure rate limiting and log rotation for syslog.
#

set -e

readonly DEFAULT_RATE_LIMIT_INTERVAL="5"
readonly DEFAULT_RATE_LIMIT_BURST="5000"

readonly SCRIPT_PATH="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
readonly DEFAULT_LOGROTATE_CONFIG_AMAZON_LINUX="$SCRIPT_PATH/logrotate-config-amazon-linux"
readonly DEFAULT_LOGROTATE_CONFIG_UBUNTU="$SCRIPT_PATH/logrotate-config-ubuntu"
readonly DEFAULT_LOGROTATE_CONFIG_RED_HAT="$SCRIPT_PATH/logrotate-config-redhat"

readonly LOGROTATE_CONFIG_AMAZON_LINUX_DEST_PATH="/etc/logrotate.d/syslog"
readonly LOGROTATE_CONFIG_UBUNTU_DEST_PATH="/etc/logrotate.d/rsyslog"
readonly LOGROTATE_CONFIG_RED_HAT_DEST_PATH="/etc/logrotate.d/syslog"

readonly SYSLOG_CONF_PATH="/etc/rsyslog.conf"

readonly LOGROTATE_GIT_URL="https://github.com/logrotate/logrotate.git"
readonly LOGROTATE_VERSION="3.11.0"

function print_usage {
  echo
  echo "Usage: configure-syslog [OPTIONS]"
  echo
  echo "Configure rate limiting and log rotation for syslog"
  echo
  echo "Options:"
  echo
  echo -e "  --rate-limit-interval\t\tThe amount of time, in seconds, over which to measure rate limiting. Set to 0 to disable rate limiting. Default: $DEFAULT_RATE_LIMIT_INTERVAL."
  echo -e "  --rate-limit-burst\t\tThe maximum messages that can happen during --rate-limit-interval before triggering rate limiting. Default: $DEFAULT_RATE_LIMIT_BURST."
  echo -e "  --logrotate-config-path\tThe path to a custom config file for logrotate. Default: rotate syslog daily, keeping one week's worth of logs."
  echo -e "  --help\t\t\tPrint this help text and exit."
  echo
  echo "Example:"
  echo
  echo "  configure-syslog --rate-limit-burst 50000"
}

# Returns true (0) if this is an Amazon Linux server at the given version or false (1) otherwise. The version number
# can use regex. If you don't care about the version, leave it unspecified.
function os_is_amazon_linux {
  local readonly version="$1"
  grep -q "Amazon Linux * $version" /etc/*release
}

# Returns true (0) if this is an Ubuntu server at the given version or false (1) otherwise. The version number
# can use regex. If you don't care about the version, leave it unspecified.
function os_is_ubuntu {
  local readonly version="$1"
  grep -q "Ubuntu $version" /etc/*release
}

# Returns true (0) if this is a CentOS server at the given version or false (1) otherwise. The version number
# can use regex. If you don't care about the version, leave it unspecified.
function os_is_centos {
  local readonly version="$1"
  grep -q "CentOS Linux release $version" /etc/*release
}

# Returns true (0) if this is a RedHat server at the given version or false (1) otherwise. The version number
# can use regex. If you don't care about the version, leave it unspecified.
function os_is_redhat {
  local readonly version="$1"
  grep -q "Red Hat Enterprise Linux Server release $version" /etc/*release
}

function assert_not_empty {
  local readonly arg_name="$1"
  local readonly arg_value="$2"

  if [[ -z "$arg_value" ]]; then
    echo "ERROR: The value for '$arg_name' cannot be empty"
    print_usage
    exit 1
  fi
}

function install_logrotate_from_source {
    sudo yum update -y
    sudo yum install -y git autoconf automake libtool make popt-devel xz
    git clone $LOGROTATE_GIT_URL /tmp/logrotate
    cd /tmp/logrotate
    git checkout tags/$LOGROTATE_VERSION
    autoreconf -fiv
    ./configure
    make
    sudo make install
    rm -rf /tmp.logrotate
}

function file_contains_text {
  local readonly text="$1"
  local readonly file="$2"
  grep -q "$text" "$file"
}

function file_exists {
  local readonly file="$1"
  [[ -f "$file" ]]
}

function append_text_in_file {
  local readonly text="$1"
  local readonly file="$2"

  echo -e "$text" | sudo tee -a "$file"
}

# Replace a line of text in a file. Only works for single-line replacements.
function replace_text_in_file {
  local readonly original_text_regex="$1"
  local readonly replacement_text="$2"
  local readonly file="$3"

  sudo sed -i "s|$original_text_regex|$replacement_text|" "$file"
}

function replace_or_append_in_file {
  local readonly original_text_regex="$1"
  local readonly replacement_text="$2"
  local readonly file="$3"

  if file_exists "$file" && file_contains_text "$original_text_regex" "$file"; then
    replace_text_in_file "$original_text_regex" "$replacement_text" "$file"
  else
    append_text_in_file "$replacement_text" "$file"
  fi
}

# For info on logrotate, see: http://www.linuxcommand.org/man_pages/logrotate8.html
function configure_logrotate {
  local readonly config_src_path="$1"
  local readonly config_dest_path="$2"

  echo "Configuring logrotate by copying config file $config_src_path to $config_dest_path"
  sudo cp "$config_src_path" "$config_dest_path"

  echo "Configuring logrotate to run hourly"
  sudo mkdir -p /etc/cron.hourly
  sudo cp /etc/cron.daily/logrotate /etc/cron.hourly/logrotate
}

# For info on syslog rate limiting, see: http://www.rsyslog.com/tag/rate-limiting/
function configure_rate_limiting {
  local readonly rate_limit_interval="$1"
  local readonly rate_limit_burst="$2"

  if [[ "$rate_limit_interval" -eq 0 ]]; then
    echo "Updating syslog config in $SYSLOG_CONF_PATH to disable rate limiting"
  else
    echo "Updating syslog config in $SYSLOG_CONF_PATH to rate limit if more than $rate_limit_burst messages are sent over a $rate_limit_interval second interval"
  fi

  replace_or_append_in_file '^\$SystemLogRateLimitInterval.*' "\$SystemLogRateLimitInterval $rate_limit_interval" "$SYSLOG_CONF_PATH"
  replace_or_append_in_file '^\$SystemLogRateLimitBurst.*' "\$SystemLogRateLimitBurst $rate_limit_burst" "$SYSLOG_CONF_PATH"
}

function configure_syslog {
  local rate_limit_interval="$DEFAULT_RATE_LIMIT_INTERVAL"
  local rate_limit_burst="$DEFAULT_RATE_LIMIT_BURST"
  local logrotate_config_path=""

  while [[ $# -gt 0 ]]; do
    local key="$1"

    case "$key" in
      --rate-limit-interval)
        rate_limit_interval="$2"
        assert_not_empty "$key" "$rate_limit_interval"
        shift
        ;;
      --rate-limit-burst)
        rate_limit_burst="$2"
        assert_not_empty "$key" "$rate_limit_burst"
        shift
        ;;
      --logrotate-config-path)
        logrotate_config_path="$2"
        assert_not_empty "$key" "$logrotate_config_path"
        shift
        ;;
      --help)
        print_usage
        exit
        ;;
      *)
        echo "ERROR: Unrecognized argument: $key"
        print_usage
        exit 1
        ;;
    esac

    shift
  done

  if os_is_amazon_linux; then
    install_logrotate_from_source
    configure_rate_limiting "$rate_limit_interval" "$rate_limit_burst"
    configure_logrotate "${logrotate_config_path:-$DEFAULT_LOGROTATE_CONFIG_AMAZON_LINUX}" "$LOGROTATE_CONFIG_AMAZON_LINUX_DEST_PATH"
  elif os_is_ubuntu; then
    configure_rate_limiting "$rate_limit_interval" "$rate_limit_burst"
    configure_logrotate "${logrotate_config_path:-$DEFAULT_LOGROTATE_CONFIG_UBUNTU}" "$LOGROTATE_CONFIG_UBUNTU_DEST_PATH"
  elif os_is_redhat || os_is_centos; then
    install_logrotate_from_source
    configure_rate_limiting "$rate_limit_interval" "$rate_limit_burst"
    configure_logrotate "${logrotate_config_path:-$DEFAULT_LOGROTATE_CONFIG_RED_HAT}" "$LOGROTATE_CONFIG_RED_HAT_DEST_PATH"
  else
    echo "ERROR: This script only supports Amazon Linux, RedHat/CentOS, and Ubuntu."
    exit 1
  fi
}

configure_syslog "$@"